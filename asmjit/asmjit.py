import AsmJit
import array
from ctypes import POINTER, pointer, c_uint8, c_uint32
from binascii import hexlify
import sys

# Bring reg names into global namespace 
_REGS_   = ['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'edi', 'esi']
# Functions worth exporting directly to importers
_FUNCS_ = ['AbsPtr', 'imm', 'uimm', 'GPVar', 'UIntFunctionBuilder0']
_GLOBALS_ = ['CALL_CONV_DEFAULT']
_MODULE_ = sys.modules[__name__]
for reg in (_REGS_ + _FUNCS_ + _GLOBALS_):
    setattr(_MODULE_, reg, getattr(AsmJit, reg))

class Code(object):
    """    
    Wrapper around the byte buffer that represents
    code generated by AsmJit
    """
    def __init__(self, code, code_size, code_maxlen=20): 
        self.ptr  = int(code)
        self.size = code_size
        self.code_maxlen = code_maxlen

        # Create ctypes to represent the code
        self.code_reprtype = (c_uint8 * min(code_maxlen, code_size))
        self.code_type = (c_uint8 * code_size)

    def toarray(self):
        code = self.code_type.from_address(self.ptr)
        return array.array('B', code)

    def tohex(self):
        return hex(self)

    def __hex__(self):
        return hexlify(self.toarray())

    def __repr__(self):
        postfix = ''
        if self.size > self.code_maxlen:
            postfix = '...'
        code = self.code_reprtype.from_address(self.ptr)
        return 'Code - ' + repr(array.array('B', code)) + postfix

class LibWrapper(object):       
    def __init__(self, base):
        self.base = base

    def __getattr__(self, attr):
        if attr not in self.__dict__:
            base = self.__dict__['base']
            return getattr(self.base, attr)
        return self.__dict__[attr]
     
class Assembler(LibWrapper):
    """ 
    Wrapper around AsmJit.Assembler
    """
    def __init__(self): 
        self.assembler = AsmJit.Assembler()
        super(Assembler, self).__init__(self.assembler)

    def __repr__(self):
        return 'Assembler - ' + repr(self.code)

    def __hex__(self):
        return hex(self.code)

    def toarray(self):
        return self.code.toarray()

    @property
    def code(self):
        c = Code(self.getCode(), self.getCodeSize())
        return c

class Compiler(LibWrapper):
    """
    Wrapper around AsmJit.Compiler
    """
    def __init__(self):
        self.compiler = AsmJit.Compiler()
        super(Compiler, self).__init__(self.compiler)
def DerefUInt32(p):
    return c_uint32.from_address(p).value

# Give importers a direct reference to underlying AsmJit
_ALL_ = ['AsmJit', 'DerefUInt32'] + _REGS_ + _FUNCS_
